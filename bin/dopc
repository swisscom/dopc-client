#!/usr/bin/env ruby

require 'gli'
require 'base64'
require 'rest-client'
require 'etc'

require 'dopc'

include GLI::App

program_desc 'CLI client for DOPc. For general errors the client will exit with 1, for usage errors with 64.'

version Dopc::VERSION

USER = Etc.getpwuid(Process.uid)
CONFIG_FILE = USER.name == 'root' ? File.join('etc', 'dopc', 'dopc.conf') : File.join(USER.dir, '.dop', 'dopc.conf')

config_file CONFIG_FILE

subcommand_option_handling :normal
arguments :strict

desc 'URL where DOPc service runs'
default_value 'http://localhost:3000'
arg_name 'url'
flag [:u, :url]

desc 'API version to use when talking to DOPc service'
default_value '1'
arg_name 'api'
flag [:a, :api]

desc 'Authentication token to use with DOPc service'
default_value ''
arg_name 'token'
flag [:t, :auth_token], :mask => true

desc 'Do not verify peer certificate when doing SSL'
switch [:i, :insecure]

desc 'Show debug output'
switch [:d, :debug]

def api(options, method, path, payload = nil)
  client = Dopc::ApiClient.new(options[:url], options[:api], options[:auth_token], options[:insecure])
  begin
    body = client.request(method, path, payload)
    return body.empty? ? {} : JSON.parse(body)
  rescue RestClient::Exception => e
    resp = e.response
    error = 'Unknown'
    if !resp.body.empty?
      begin
        json = JSON.parse(resp.body)
        error = json['error'] if json.has_key?('error')
      rescue JSON::ParserError
        error = resp.body.to_s
      end
    end
    exit_now!("#{resp.code}: #{error}", 1)
  end
end

def exec_header
  "ID | Plan | Task | Status | Created | Started | Duration | Stepset | Remove disk"
end

def exec_string(hash)
  s = ''
  s += hash['id'].to_s
  s += ' | ' + hash['plan']
  s += ' | ' + hash['task']
  s += ' | ' + hash['status']
  s += ' | ' + Dopc::Util.ago(Time.parse(hash['created_at']))
  if hash['started_at']
    s += ' | ' + Dopc::Util.ago(Time.parse(hash['started_at']))
  else
    s += ' | -'
  end
  if hash['finished_at']
    s += ' | ' + Dopc::Util.ago(Time.parse(hash['finished_at']), Time.parse(hash['started_at']))
  else
    s += ' | -'
  end
  s += ' | ' + (hash['stepset'] ? hash['stepset'] : '-')
  s += ' | ' + (hash['rmdisk'] ? hash['rmdisk'].to_s : '-')
  s
end

pre do |global_options,command,options,args|
  if global_options[:debug]
    ENV['GLI_DEBUG'] = 'true'
    RestClient.log = 'stderr'
  end
  true
end

desc 'Ping the API'
command :ping do |c|
  c.action do |global_options, options, args|
    response = api(global_options, :get, 'ping')
    puts response['pong']
  end
end

desc 'Manage plans'
command :plan do |c|
  c.desc 'List all plans'
  c.command :list do |sc|
    sc.action do |global_options, options, args|
      response = api(global_options, :get, 'plans')
      response['plans'].each{|p| puts p['name'] }
    end
  end
  c.arg '<plan_name>'
  c.desc 'Get a plan'
  c.command :get do |sc|
    sc.flag [:v, :version], :desc => 'Get specific version of plan (if not specified then get latest version)'
    sc.action do |global_options, options, args|
      plan = args[0]
      help_now!('Specify plan to retrieve') unless plan
      payload = options[:v] ? {version: options[:v]} : nil
      response = api(global_options, :get, "plans/#{plan}", payload)
      content = Base64.decode64(response['content'])
      puts content
    end
  end
  c.arg '<plan_name>'
  c.desc 'Get version list of a plan'
  c.command :versions do |sc|
    sc.action do |global_options, options, args|
      plan = args[0]
      help_now!('Specify plan to retrieve') unless plan
      response = api(global_options, :get, "plans/#{plan}/versions")
      response['versions'].each{|v| puts v['name']}
    end
  end
  c.arg '<file>'
  c.desc 'Add a plan from file'
  c.command :add do |sc|
    sc.action do |global_options, options, args|
      file = args[0]
      help_now!('Specify plan file to add') unless file
      content = Base64.encode64(File.read(file))
      payload = {content: content}
      response = api(global_options, :post, 'plans', payload)
      puts "Added plan '#{response['name']}'"
    end
  end
  c.arg '<file>'
  c.desc 'Update a plan from a file'
  c.command :update do |sc|
    sc.action do |global_options, options, args|
      file = args[0]
      help_now!('Specify plan file to update from') unless file
      content = Base64.encode64(File.read(file))
      payload = {content: content}
      response = api(global_options, :put, 'plans', payload)
      puts "Updated plan '#{response['name']}'"
    end
  end
  c.arg '<plan_name>'
  c.desc 'Delete a plan'
  c.command :delete do |sc|
    sc.action do |global_options, options, args|
      plan = args[0]
      help_now!('Specify plan to delete') unless plan
      response = api(global_options, :delete, "plans/#{plan}")
      puts "Deleted plan '#{response['name']}'"
    end
  end
  c.arg '<plan_name>'
  c.desc 'Reset the state of a plan'
  c.command :reset do |sc|
    sc.switch [:f, :force], :desc => "Force state reset"
    sc.action do |global_options, options, args|
      plan = args[0]
      help_now!('Specify plan to reset') unless plan
      response = api(global_options, :put, "plans/#{plan}/reset", {force: options[:force]})
    end
  end
  c.arg '<plan_name>'
  c.desc 'Get the current run state of a plan'
  c.command :state do |sc|
    sc.action do |global_options, options, args|
      plan = args[0]
      help_now!('Specify plan to get state from') unless plan
      response = api(global_options, :get, "plans/#{plan}/state")
      puts response['state']
    end
  end
end

desc 'Manage plan executions'
command :execution do |c|
  c.desc 'List all executions'
  c.command :list do |sc|
    sc.action do |global_options, options, args|
      response = api(global_options, :get, 'executions')
      puts exec_header
      response['executions'].each{|e| puts exec_string(e)}
    end
  end
  c.arg '<execution_id>'
  c.desc 'Get an executions'
  c.command :get do |sc|
    sc.action do |global_options, options, args|
      execution = args[0]
      help_now!('Specify an execution to get') unless execution
      response = api(global_options, :get, "executions/#{execution}")
      puts exec_header
      puts exec_string(response)
    end
  end
  c.arg '<execution_id>'
  c.desc "Get an execution's log"
  c.command :log do |sc|
    sc.action do |global_options, options, args|
      execution = args[0]
      help_now!('Specify an execution to get the log from') unless execution
      response = api(global_options, :get, "executions/#{execution}/log")
      puts response['log']
    end
  end
  c.arg_name '<plan_name>'
  c.desc 'Setup a plan (deploy and run)'
  c.command :setup do |sc|
    sc.flag [:s, :stepset], :desc => 'Optionally set a stepset for DOPi instead of using the default one'
    sc.action do |global_options, options, args|
      name = args[0]
      help_now!('Specify a plan to set up') unless name
      payload = {plan: name, task: 'setup'}
      payload.merge!({stepset: options[:stepset]}) if options[:stepset]
      response = api(global_options, :post, "executions", payload)
      puts "Added execution '#{response['id']}'"
    end
  end
  c.arg_name '<plan_name>'
  c.desc 'Deploy a plan'
  c.command :deploy do |sc|
    sc.action do |global_options, options, args|
      name = args[0]
      help_now!('Specify a plan to deploy') unless name
      payload = {plan: name, task: 'deploy'}
      response = api(global_options, :post, "executions", payload)
      puts "Added execution '#{response['id']}'"
    end
  end
  c.arg_name '<plan_name>'
  c.desc 'Run a plan'
  c.command :run do |sc|
    sc.flag [:s, :stepset], :desc => 'Optionally set a stepset for DOPi instead of using the default one'
    sc.action do |global_options, options, args|
      name = args[0]
      help_now!('Specify a plan to set up') unless name
      payload = {plan: name, task: 'run'}
      payload.merge!({stepset: options[:stepset]}) if options[:stepset]
      response = api(global_options, :post, "executions", payload)
      puts "Added execution '#{response['id']}'"
    end
  end
  c.arg_name '<plan_name>'
  c.desc 'Undeploy a plan'
  c.command :undeploy do |sc|
    sc.switch [:r, :rmdisk], :desc => 'Whether to delete or keep disks'
    sc.action do |global_options, options, args|
      name = args[0]
      help_now!('Specify a plan to set up') unless name
      payload = {plan: name, task: 'undeploy', rmdisk: options[:rmdisk]}
      response = api(global_options, :post, "executions", payload)
      puts "Added execution '#{response['id']}'"
    end
  end
  c.arg '<execution_id>'
  c.desc 'Remove an execution, does only work if it\'s not running'
  c.command :remove do |sc|
    sc.action do |global_options, options, args|
      execution = args[0]
      help_now!('Specify an execution to remove') unless execution
      response = api(global_options, :delete, "executions/#{execution}")
      puts "Removed execution '#{response['id']}'"
      puts exec_header
      puts exec_string(response)
    end
  end
  c.desc 'Clear executions'
  c.command :clear do |sc|
    sc.flag [:s, :status], :multiple => true, :desc => "Executions with specified status(es) are removed", :default_value => 'done'
    sc.flag [:p, :plan], :desc => "Remove only executions of this plan"
    sc.action do |global_options, options, args|
      payload = {statuses: Array(options[:status])}
      payload.merge!({plan: options[:plan]}) if options[:plan]
      response = api(global_options, :delete, "executions", payload)
      puts "Removed executions:"
      puts exec_header
      response['executions'].each{|e| puts exec_string(e)}
    end
  end
end

exit run(ARGV)
